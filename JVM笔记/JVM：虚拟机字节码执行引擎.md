# JVM：虚拟机字节码执行引擎

## 目录

1、概述

2、运行时栈帧结构

3、方法调用

4、基于栈的字节码解释执行引擎

## 8.1、概述

在Java虚拟机规范中制定的虚拟机字节码执行引擎的模型：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

不同的虚拟机实现里面，执行引擎可能有解释执行、编译执行，或两者兼备。

## 8.2、运行时栈帧结构

栈帧：是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经确定了，并且写入到方法表的code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，即只对栈顶的栈帧操作。

### 8.2.1 局部变量表

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

在Java程序被编译为class文件时，就在方法的code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。

无效的图片地址

局部变量表的容量以变量槽（variable slot)为最小单位，虚拟机规范中并没有指明一个slot应该占用的内存空间大小，只是说明每个slot都应该能存放一个boolean, byte, char, short, int, float, reference或returnAddress。

注意到，以上的数据类型都是32位（4个字节）以内的。其中reference是对象的引用，returnAddress是为字节码指令jsr, jsr_w和ret服务的，它指向了一条字节码指令的地址。

对于64位的数据类型，虚拟机将会以高位在前的方式为其分配两个连续的slot空间。由于局部变量表建立在线程的堆栈上，是线程私有数据，无论读写两个连续的slot是否是原子操作，都不会引起数据安全问题。

局部变量表的slot是可重用的，slot可以被线程内其他变量使用，但是对slot的多引用会影响垃圾回收。

### 8.2.2 操作数栈

操作栈，作为方法执行过程中的参数存储。操作数栈的最大深度，在编译时被写入到code属性的max_stacks数据项之中。

在方法执行过程中会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，以iadd指令为例，在整型数相加时取栈顶的两个元素必须都是int型，不能一个long和一个float.

另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。单数大多数虚拟机的时下里都会做一些优化处理，令局部变量表和操作数栈部分重叠，从而可以共用一部分数据避免复制传递。

### 8.2.3 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

通过类文件结构，我们指导class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每次的运行期间转化为直接引用，这部分称为动态连接。

### 8.2.4 方法返回地址

当一个方法被执行后，有两种方式退出这个方法。

第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。

另外一种退出方式，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理、再本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种方式称为异常完成出口。

无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要再找栈帧中保存一些信息，用来帮助恢复它上层方法的执行状态。

方法退出的过程等同于把当前栈帧出栈，因此退出时可能执行：恢复上层方法的局部变量表和操作数栈、把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

## 8.3、方法调用

方法调用不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（调用哪一个），暂时还不涉及方法内部的具体运行过程。

### 8.3.1 解析

所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。

换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。

Java中，“编译器可知、运行期不可变”这个要求让静态方法和私有方法两大类，适合在类加载阶段进行解析。与之相对应的，Java虚拟机中提供了四条方法调用字节码指令：

1）invokestatic 调用静态方法

2）invokespecial 调用实例构造器<init>方法、私有方法和父类方法

3）invokevirtual 调用所有的虚方法

4）invokeinterface 调用接口方法，会在运行时再确定一个实现此接口的对象

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法就称为虚方法。

Java中final方法由于无法被覆盖，所以也就是个非虚方法。

1、静态分派

所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。

静态分派的最典型应用就是方法重载，当代码中定义了两个静态类型相同、实际类型不同的变量，虚拟机（准确来说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。

2、动态分派

在运行期根据实际类型确定方法执行版本的分派过程，称为动态分派。

以invokevirtual指令的多态查找过程说起，invokevirtual指令的运行时解析过程大致如下：

1）找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。

2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回Java.lang.IllegalAccessError异常。

3）否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。

4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令吧常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言的方法重写的本质。

总的来说，编译阶段的选择过程是静态分派，运行阶段的选择过程是动态分派。

3、单分派与多分派

从定义上，方法的接受者和方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。

当前的Java语言中，静态分派是多分派，动态分派是单分派。

4、虚拟机动态分派的实现

虚拟机是如何做到动态分派的？

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真的进行如此频繁的搜索。

面对这种情况，最常用的“稳定优化”手段就是为类在此方法区中建立一个虚方法表（Virtual Method Table, 也就是vtable），使用虚方法表索引来代替元数据查找以提高性能。

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法（如上Son），子类方法表中的地址会被替换为指向子类实现版本的入口地址。

为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变化时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。

## 8.4、基于栈的字节码解释执行引擎

许多虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。

### 8.4.1 解释执行

无论解释还是编译，大部分程序代码到物理机的目标代码或虚拟机指令之前，都需要经过如上的步骤。抽象语法树之后，中间的分支就是解释执行，底部的分支就是编译执行。

Java在初生时是“解释执行”的语言，但随着发展各个语言包括Java都包含了解释执行和编译执行，已经没有明确的界限。不论是哪种执行，都需要完成词法分析到抽象语法树的步骤，再结合不同分支的步骤催生了各种可能的执行器。

Java中的编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。

### 8.4.2 基于栈的指令集与基于寄存器的指令集

Java编译器输出的指令流，基本上是一种基于栈的指令集架构， 指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。

与之相对的是基于寄存器的指令集，最典型的就是x86的二地址指令集，就是现在主流PC中直接支持的指令集架构。

相比较，基于栈的指令集最主要的优点是可移植性，栈实现在内存之中，不受CPU架构的约束。但是因此频繁的栈操作就等于频繁内存访问，内存因此成为执行速度的瓶颈。

基于寄存器的指令集，速度始终是当前最快的，因为寄存器直接集成在CPU中。但CPU的硬件差异也约束了这一指令集，例如32位x86体系的处理器中提供8个32位的寄存器，而ARM体系的CPU则提供了16个32位的通用寄存器。

### 8.4.3 基于栈的解释器执行过程

用一个例子来演示。

首先，Javap提示这段代码需要操作栈深度为2，局部变量空间为4个slot。

如上的字节码指令，push是将整型值推入操作数栈顶，store是从栈顶取出元素存放到局部变量表中，load是从局部变量表中整型值复制到操作数栈顶，add和mul是对操作数栈中变量的操作，最后return返回结果。

这里的例子仅仅是一个概念模式，实际上会更复杂和对字节码进行优化。但是这里可以看出，核心就是利用操作数栈，并且多次操作数栈的存取意味着多次内存访问，印证了理论。
