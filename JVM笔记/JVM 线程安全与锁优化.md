# JVM 线程安全与锁优化



## 13.3 锁优化

### 13.3.1 自旋锁与自适应自旋

讨论synchronized的互斥同步时，提到了对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大压力。

实际上许多应用对共享数据都只会锁定很短的一段时间，为此切入到内核态是浪费资源的。而且如今大多数计算机都是多核，也就是线程等待的时间也变短了，那还有没有必要切入内核态去挂起，再很快恢复呢？

当目标共享资源被锁住时，我们可以让后面请求锁的那个线程”稍等一会儿“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。”稍等一会儿“的方式，就是让线程执行一个忙循环（自旋），这项技术就是**自旋锁**。



自旋锁在Java 1.4.2中已经引入但默认关闭，使用-XX: +UseSpinning参数可以开启，而从JDK6中改为默认开启。

自旋锁是为了避免短时间等待时挂起线程的不必要开销，如果等待时间过长虚拟机就还是会自动切换到挂起线程中。自旋锁的默认次数是10次，用户也可以使用-XX: PreBlockSpin来自行更改。

自旋锁也是要占用处理器时间的，同样是一种性能开销。



**自适应的自旋锁**：虚拟机加上了一重校验机制，根据前一次在同一锁上的自旋时间及锁的拥有者的状态来决定的。

如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机认为这次自旋也可能再次成功，进而允许自旋更长时间比如100次忙循环。反之，如果某个锁很少被获得，那以后要获取这个锁时都可能直接省略自旋，直接挂起线程。

这里可以看到，虚拟机自己做了预测。



## 13.3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。

锁消除的主要判定依据来源于逃逸分析（深入理解Java虚拟机第11章）的数据支持，如果判断到一段代码中，在对上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

这里有一个问题：如果代码中没有使用synchronized或者其他lock，是否还需要锁消除？

实际上，锁消除不仅是对程序中主动加入的锁，常用类的函数方法中带锁的都有很多，同步的代码在Java程序中是非常频繁出现的。



实例：

![1593950666636](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1593950666636.png)

在JDK 5之后，如上代码的拼接，是通过StringBuilder对象的连续append操作来的。StringBuilder是非线程安全的，不加锁。

![1593950748636](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1593950748636.png)

这里我们用StringBuffer来说明同步问题，当使用StringBuffer.append方法后，每个append操作都有一个同步块，锁就是sb对象。

虚拟机观察变量sb，经过逃逸分析后会发现它的动态作用域被限制在concatString()方法内部。也就是sb的所有引用都永远不会被逃逸到concatString方法之外，这样安全的锁就可以被消除掉。



## 13.3.3 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。

大多数情况下，上面的原则是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

![1593950748636](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1593950748636.png)

如上代码中，连续的append方法就是连续的互斥同步操作。如果虚拟机探测是有这样一串零碎的操作都对同一个对象加锁，那么将会把加锁同步的范围扩展到整个操作序列的外部，即第一个append操作之前直至最后一个append操作之后。

这样只需要加锁一次，就是锁粗化。



## 13.3.4 轻量级锁

轻量级锁是JDK1.6中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言。

因此传统的锁机制就被称为“重量级锁”。

注意，轻量级锁并不是用于替代重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

理解轻量级锁，必须介绍HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。

HotSpot虚拟机的对象头（Object header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（hashcode）、GC分代年龄（generation GC age）等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个bits，官方称它为“Mark Word", 它是实现轻量级锁和偏向锁的关键。

另外一部分用于存储指向方法去对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。

例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象hashcode，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下。

**轻量级锁是如何执行的呢？**在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。

然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（最后两个bits）将转变为“00”，即表示此对象处于轻量级锁定的状态。

如果这个更新操作失败了，虚拟机会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。

如果有两条以上的线程争用同一个锁，那轻量级锁就不载有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。

如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁的性能，是在锁不存在竞争的前提下，通过CAS操作减少互斥量的开销。但是如果存在锁竞争，从轻量级锁转换到重量级锁，就变成了CAS+互斥量，变得更慢了。

## 13.3.5 偏向锁

偏向锁也是JDK1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。

偏向锁，偏向的是第一个获取它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。

偏向锁的执行过程：假设当前虚拟机启动了偏向锁（参数-XX: +UseBiasedLocking，这是JDK1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01“，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何公布操作（例如Locking, Unlocking 及对Mark Word的Update等）。

当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。

偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个可取舍的操作。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。这时，可以用-XX: -UseBiasedLocking来禁止偏向锁优化反而可以提升性能。

