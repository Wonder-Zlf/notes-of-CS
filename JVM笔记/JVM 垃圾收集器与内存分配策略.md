# JVM 垃圾收集器与内存分配策略

## 3.1 概述

垃圾回收（garbage collection，GC），不只是Java的伴生产物，1960年MIT的Lisp是第一门使用内存动态分配和垃圾回收的语言。

看Java内存运行区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域伴随线程终止，不需要考虑动态内存管理。

而Java堆和方法区则不同，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能指导会创建哪些对象，这部分才是垃圾收集器负责的。

## 3.2 对象已死？（对象标记算法）

堆中几乎存放着Java中的所有对象实例，垃圾收集器对堆进行回收前，第一件事就是确定哪些对象死去了（不再被引用）。

这部分内容可以算是对象标记算法。

### 3.2.1 引用技术算法

引用技术算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数值就减1；任何时刻计数器都为0的对象就不可能再被使用的。

Java中未使用这一算法，原因是它很难解决对象之间互相循环引用的问题。

### 3.2.2 根搜索算法

根搜索算法：通过一系列的名为“GC ROOTS”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

Java中可以作为GC Roots的对象包括：

1）虚拟机栈（栈帧中的本地变量表）中引用的对象

2）方法区中的类静态属性引用的对象

3）方法区中的常量引用的对象

4）本地方法栈中JNI（即一般说的native方法）的引用对象

### 3.2.3 再谈引用

JDK1.2之前，Java中的引用定义很传统：如果reference类型的书中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表一个引用。

实际上，Java调优更需要引用的优先级排序，随着内存空间变化来逐次地回收相对无用的对象。相应地，Java的引用扩展为强引用、软引用、弱引用、虚引用。

### 3.2.4 生存还是死亡？

根搜索中没有GC Roots引用的一个对象，会被第一次标记。之后，对象会被判断是否要执行finalize方法，在执行finalize方法后会被第二次标记。然后等待垃圾回收。

只有在finalize方法中被再次引用，才能跳出。

### 3.2.5 方法区的回收

相比于Java堆中的垃圾回收70%-95%的空间，方法区（永久代）的垃圾回收百分比是很低的。

但是永久代中的垃圾也需要回收，主要是废弃常量和无用的类，否则同样存在溢出风险。

## 3.3 垃圾回收算法

### 3.3.1 标记-清除算法

标记就是对象标记，清除则是之后统一回收垃圾对象。

存在的两个问题：一是效率低下，二是产生空间碎片。

### 3.3.2 复制算法

复制算法，是将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

现代的商业虚拟机都采用这种算法来回收新生代。

### 3.3.3 标记-整理算法

同样是先标记，但是之后先让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。

### 3.3.4 分代收集算法

分代手机与上述算法并不冲突，将Java堆中对象根据存活周期分为新生代和老年代，不同区域采用不同的收集算法。

## 3.4 垃圾收集器

垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。每个JVM是以进程的方式在OS中存在，垃圾收集器就是进程内的类似0号线程的存在。

以上，如果两个收集器之间存在连线，就说明它们可以搭配使用。

垃圾收集器：

1）serial收集器：最基本、最老的收集器，单线程

2）Parnew收集器：serial收集器的多线程版本

3）Parallel Scavenge收集器：与parnew类似，可控制吞吐量

4）serial old收集器

5）parallel old收集器

6）CMS收集器

7）G1收集器

## 问题：什么时候Full GC? 什么时候Minor GC?

首先说明一下，真实的垃圾回收器的划分更为复杂，不仅仅按Java堆中的区域来回收。

Java堆中有年轻代Eden, From Survivor, To Survivor, 老年代Old, 永久代（方法区）。

Full GC通常理解为对整个Java堆（包括方法区）进行垃圾回收，minor GC指对Java堆中的年轻代回收，major GC指对Java堆中的老年代回收。

Minor GC触发条件：Eden区满了，就触发

Full GC触发条件：

1）程序调用System.gc, 系统建议，但是非必需

2）老年代空间不足

3）方法区空间不足

4）通过minor GC后会进入老年代的平均大小大于老年代可用内存，则不进行minor GC转而直接Full GC

5）Minor GC后年轻代内部Eden, From Survivor转移到To Survivor的对象大于S1的内存，将转而进入老年代并且老年代内存不足，同上直接Full GC

## 问题：多次垃圾收集后方法区也不够用该怎么办？

方法区溢出（内存溢出）

## 3.5 内存分配与回收策略

JVM的自动内存管理从首尾解决了两个问题：给对象分配内存和回收分配给对象的内存

### 3.5.1 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次minor GC。

### 3.5.2 大对象直接进入老年代

大对象是，需要大量连续内存空间的Java对象。典型的，就是很长的字符串和数组。

反之如果不这样，就可能在eden区及两个survivor区之间发生大量的内存拷贝（垃圾收集时）。

### 3.5.3 长期存活的对象进入老年代

eden传递到survivor的对象，每经过一次minorGC就age增加1，指导age到达15，就会被晋升到老年代中。

### 3.5.4 动态对象年龄判断

如果在survivor中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。

### 3.5.5 空间分配担保

在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。

如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC; 如果不允许，则也要改为进行一次Full GC.

