# JVM Java内存区域与内存溢出异常

## 2.2 运行时数据区域

Java虚拟机会把Java程序执行过程中的内存分为若干个不同区域。

### 2.2.1 程序计数器

程序计数器是一块较小的空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能回复到正确的执行位置，每条线程都需要有一个独立的程序计数器。

### 2.2.2 Java虚拟机栈

与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

### 2.2.3 本地方法栈

虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈则为虚拟机使用到native方法服务。

有的虚拟机会把虚拟机栈和本地栈合并。

### 2.2.4 Java堆

Java堆在JVM的内存中占据最大区域，是被所有线程共享的一块，在虚拟机启动时创建。Java堆的唯一目的是存放对象实例。

Java堆是垃圾收集器管理的主要区域，由于分代回收算法，Java堆中还可以细分为：新生代（Eden, From Survivor, To Survivor）、老年代、甚至永久代（方法区）

Java堆可以是物理上不连续的。

### 2.2.5 方法区

方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类、常量、静态变量、即时编译器编译后的代码等数据。

方法区并不严格属于Java堆，也不严格等于永久代。

### 2.2.6 运行时常量池

运行时常量池是方法区的一部分。

class文件中除了有类的版本、字段、方法、接口等信息，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### 2.2.7 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

这是基于通道channel与缓冲区buffer的I/O方式，使用native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。

直接内存显然不受Java堆大小的限制，但是限于本机总内存的大小。所以如果忽略了配置JVM的直接内存，导致直接内存总和大于本机物理内存，也会OutOfMemoryError.

## 2.3 对象访问

Java对象访问的主流方式有两种：使用句柄和直接指针。

1）如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，二句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下：

2）如果使用直接指针访问，Java堆中的布局就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下：

这里，使用句柄的最大好处是reference中存储的是稳定的句柄地址，在对象移动（垃圾回收）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

使用直接指针，则节省了一次指针定位的时间开销，因此速度更快。积少成多后，能够为JVM提升可观的性能。

## 2.4 OurOfMemoryError异常

1）Java堆溢出

2）虚拟机和本地方法栈溢出

3）运行时常量池溢出

4）方法区溢出

5）本机直接内存溢出