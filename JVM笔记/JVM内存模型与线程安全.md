# JVM内存模型与线程安全

## 12.1 概述

并发的两个层面，一是底层的CPU多线程运行，二是服务端的并发请求处理。第一点，是对CPU计算能力的“压榨”，和对处理器与存储间的数据同步时间优化。第二点，当前已经更多的由中间件和框架来封装。

## 12.2 硬件的效率与一致性

在Java虚拟机并发的展开前，先来看看物理机中的并发。

1）所有的运算除了处理器，都离不开与内存的交互。由于计算机的存储设备与处理器的运算速度之间有几个数量级的差距，所以现代计算机系统都不得不加入高速缓存（cache）来作为内存与处理器之间的缓冲。

2）cache引入的新问题：缓存一致性（cache coherence）。多核处理器中，每个处理器都有自己的cache，而它们又都共享同一主内存。当不同处理器同步数据到主内存中时，如果冲突该以谁的为准？

解决一致性问题，需要各个处理器都遵循一些协议，在读写时要根据协议来进行操作，如MSI, MESI, MOSI, Synapse, Firefly及Dragon Protocol等等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作时具有可比性的。

3）为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此如果存在一个计算任务以来另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。

与处理器的乱序执行优化类似，Java虚拟机的即时编译器也有类似的指令重排序（Instruction Reorder）优化。

## 12.3 Java内存模型

Java内存模型JMM，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。

相比下，主流程序语言（C/C++）直接使用物理硬件（操作系统的内存模型），会由于不同平台上的内存模型的差异，导致程序在一套平台上并发完全正常，而另一套上却经常出错。

### 12.3.1 主内存与工作内存

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

此处的变量与Java编程中所说的略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。

为了获得较好的性能，JMM并不限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利。

JMM规定了所有的变量存储在主内存中。每个线程还有自己的工作内存（working memory，可与前面所讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系。

这里所讲的主内存、工作内存与本书中第2章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的划分。主内存就是硬件的内存，工作内存优先存储于寄存器和高速缓存中。

### 12.3.2 内存间交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，JMM定义了以下八种操作来完成：

1）lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。

2）unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

3）read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。

4）load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存的变量副本中。

5）use：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。

6）assign：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

7）store：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用

8）write：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

另外，JMM也定义了使用的规则：

1）不允许read和load，store和write操作之一单独出现，即主内存和工作内存之间互相拒绝

2）不允许一个线程丢弃assign操作，即变量在工作内存中改变了必须同步回主内存

3）没有发送任何assign，不允许同步数据回主内存

4）新的变量只能在主内存中产生，也就是一个被修改的变量必须先从主内存中复制过来

5）一个变量同一时刻只能被一条线程lock，但lock操作可以重复执行多次，相应地要unlock多次

6）如果对一个变量lock，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。

7）如果一个变量没有被lock，则不允许unlock，也不能unlock非本线程锁定住的变量

8）对一个变量unlock前，必须先把此变量同步回主内存中（store和write）

### 13.3.3 对于volatile型变量的特殊规则

**当一个变量被定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性。**这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，变量值在线程间传递均需要通过主内存来完成。

volatile变量在各个线程的工作内存中不存在一致性问题，因为每次使用前都要先从主内存刷新。但是并不意味着volatile可以保证并发下安全，因为Java里面的运算并非原子操作，实际的原子级变量计算中并不是每次先从主内存刷新。

以一个自增运算为例，当变量被取到操作栈顶时数据是最新的。但是当iadd等操作时，数据在主内存中可能已经被其他线程修改，这时操作后的结果再同步回主内存，反而是错误结果了。

严格来看，字节码指令也常常不是个原子操作，而是许多行代码执行才能实现语义。要到汇编代码级别，才能是原子操作。

在不符合以下两条规则的运算场景中，我们仍然要加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。

1）运算结果并不依赖变量的当前值，或者能够确保只有单一线程的修改变量的值

2）变量不需要与其他的状态变量共同参与不变约束

**使用volatile变量的第二个语义是禁止指令重排序优化。**普通的变量仅仅会保证在改方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。

比较volatile与锁：

1）volatile变量读操作的性能消耗与普通变量几乎没有区别，但是写操作上可能会慢一些，因为它需要在本地代码中加入很多内存屏障（memory barrier）指令来保证处理器不发生乱序执行。

2）因此volatile的总开销大多数场景下仍然比锁更低，即使锁机制已经做了很多消除和优化。

在两者间做选择，具体还是volatile能否满足场景需求。

volatile的使用规则：

1）内存交互协议中，read, load和use动作必须连续，保证总能从主内存中刷新到最新数据。

2）assign, store, write动作必须连续，保证每次在某个线程的工作内存中对变量的修改都能立刻同步回主内存中。

3）同线程下，对volatile变量V的内存交互操作，整体要先于volatile变量W。

### 12.3.4 对于long和double型变量的特殊规则

虚拟机规范中允许，将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机不保证64位数据类型的load, store, read, write这四个操作的原子性。这点就是long和double的非原子协定（Nonatomic Treatment of double and long Variables）。

但是实际上，常见的虚拟机都把64位的读写操作作为原子操作来对待和实现。

### 12.3.5 原子性、可见性与有序性

1）原子性

有Java内存模型直接保证的原子性变量操作包括read, load, assign, store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的（long和double的非原子性协定例外）。

如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求。用户甚至可以直接使用synchronized（monitorenter和monitorexit）来保证块之间的原子性。

2）可见性

可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改（刷新）。

volatile强制每次使用前从主内存刷新变量到线程工作内存，每次赋值后从线程工作内存同步回主内存。

synchronized和final关键字也能保证可见性，synchronized中的unlock操作要求先把变量同步回主内存，final修饰的字段一旦被初始化完成不可修改并且在其他线程可见。

3）有序性

Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”和“工作内存与主内存同步延迟”现象。

Java中提供了volatile和synchronized两个关键字来保证线程之间擦欧总的有序性，volatile包含了禁止指令重排序，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”。

### 12.3.6 先行发生原则

Java语言中有一个“先行发生（happens-before）”原则，可以省去很多使用volatile和synchronized来控制代码有序性的工作。

但Java内存模型中“天然的”先行发生关系是有限的，其他情况下仍然需要编码时主动添加锁等去控制操作间的先后顺序。

要强调的是，先行发生原则不代表是代码执行的时间先后顺序，只要在满足“线程内串行语义”，满足并发安全即可。

Java自带的happens-before：

1）程序次序原则（program order rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

2）管程锁定原则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。

3）volatile变量规则（volatile variable rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。“后面”同样是时间先后。

4）线程启动规则（Thread Start rule）：Thread对象的start()方法先行发生于此线程的每个动作。

5）线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join方法结束，thread.isAlive的返回值等手段检测到线程已经终止执行。

6）线程中断规则（Thread interruption rule）：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过thread.interrupted方法检测到是否有中断发生

7）对象终结规则（Finalizer rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize方法的开始

8）传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就得出A先行于C的结论。

## 12.4 Java与线程

并发不一定要依赖多线程（如PHP中常见多进程并发），但是Java里谈论并发，大多数都与线程脱不开关系。

### 12.4.1 线程的实现

线程是比进程更轻量级的调度执行单位，线程的使用可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的最基本单位）。

主流的OS都提供了线程实现，JVM下每个Thread类的实例就代表一个线程。不过Thread类与大部分的Java API有显著差别，它的所有关键方法都被声明为native。也就是它们都没有使用或无法使用与底层OS无关的手段来实现，由此你可以看出Java的线程实现是借助OS的线程实现方式达到的。

OS中实现线程主要有三种方式：使用内核线程实现，使用用户线程实现，使用用户线程加轻量级进程混合实现。

1、使用内核线程实现

内核线程（Kernel Thread, KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接去使用内核线程，二是去使用内核线程的一种高级接口——轻量级进程（Light weight process, LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。

这种轻量级进程与内核线程之间1:1的关系称为1:1的关系称为一对一的线程模型。

由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续跟踪，但是轻量级进程具有它的局限性：1）由于是基于内核线程实现的，所以各种进程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。2）每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

2、使用用户线程实现

默认的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以非常快速且低消耗，也可以支持更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

这种进程与用户线程间1:N的关系称为一对多的线程模型。

使用用户线程的难点在于使用处理器资源，OS是只把处理器资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来都很困难，甚至不可能完成。

现在很少程序，包括Java语言，还在使用用户线程。

3、混合实现

用户线程还是完全建立在用户空间中，但是同时调用内核提供的轻量级接口，用于解决掉处理器映射这些复杂的问题。

这种模式下，用户线程和轻量级进程的数量比是不定的，是M:N的关系，属于多对多线程模型。

4、Java的线程实现

JDK1.2之前，Java是基于用户线程实现的。JDK1.2开始，线程模式被替换为基于OS原生线程模式来实现。

也就是底层OS用什么，JVM就对应设置。

### 12.4.2 Java线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。

协同式调度的多线程系统，线程自己控制线程切换，没有同步问题。但是线程自己也控制了CPU时间，很容易线程阻塞挂死系统。

抢占式，则是系统来分配执行时间，例如时间片轮转。Java也是使用的抢占式线程调度。

在Java多线程中，可以设置线程优先级来分配更多时间，对应到OS中的线程优先级，例如Solaris和windows。

### 12.4.3 状态转换

Java中定义线程的6中进程状态：

新建、运行、无限期等待（waiting）、限期等待（Timed waiting）、阻塞（Blocked）、结束（Terminated）

