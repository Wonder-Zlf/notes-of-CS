# JVM: 类文件结构

## 6.2 无关性的基石

Java虚拟机的价值，“一次编写，到处运行”。

为了与平台如windows这样的解耦，虚拟机如JVM都使用同一的程序存储格式——字节码。JVM中，使用Java编译器可以把Java代码编译为存储字节码的class文件。

使用JRuby等其他语言的编译器一样可以把程序代码编译为class文件，虚拟机不关心class的来源是什么语言，只要它符合class文件应有的结构就可以在Java虚拟机中运行。

## 6.3 class类文件的结构

class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在class文件之中，中间没有添加任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

根据Java虚拟机规范的规定，class文件格式采用一种类似C语言结构体的伪结构体来存储，这种伪结构中只有两种数据类型：无符号数和表。后面的解析都要以这两种数据类型为基础。

无符号数属于基本的数据类型，以u1, u2, u4, u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值、或者按照UTF-8编码构成字符串值。

表是由多个无符号数或其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info"结尾。表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表。

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一个类型的数据为某一个类型的集合。

要强调，Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以每个数据项无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

### 6.3.1 魔数与Class文件的版本

每个class文件的头4个字节称为魔数（magic number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif和jpeg等在文件头中都存有魔数。

使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以很随意地被改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆即可。

Class文件的魔数值为：0xCAFEBABE

紧接着的是class文件的版本号：第5和6个字节是次版本号（Minor version），第7和8个字节是主版本号（major version）。Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1（JDK1.0~1.1使用了45.0--45.3的版本号），高版本的JDK能向下兼容以前版本的class文件，但不能运行以后版本的茶历史上文件，即时文件格式并未发生变化。

提供一段简单的Java代码，后续使用JDK1.6编译输出的class文件来讲解。

使用十六进制编辑打开这个class文件，可以看到4个字节的十六进制表示的是0xCAFEBABE, 代表次版本号的第5个和第6个字节值为0x0000, 而主版本号是0x0032, 即十进制的50，该版本号说明这个是可以被jdk1.6或以上版本的虚拟机执行的class文件。

下面列举了从JDK1.1到1.7之间，主流JDK版本编译器输出的默认和可支持的class文件版本号。

### 6.3.2 常量池

紧接着主次版本号之后的是常量池入口，常量池是class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，同时它还是在class文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口放置一项u2类型的数据，代表常量池容量计数值。与Java中语言习惯不一样的是，这个容量技术是从1而不是0开始。

如上，常量池容量为十六进制数0x0016, 即十进制的22，这就代表了常量池中有21项常量，索引值为1-21。

制作class文件格式规范时，将第0项常量空出来是有特殊考虑的，这样是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的意思，这种情况就可以把索引值置为0来表示。

常量池之中主要存放两大类常量：字面量和符号引用。

字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。

而符号引用则属于编译原理方面的概念，包括了下面三类常量：

1）类和接口的全限定名（fully qualified name）

2）字段的名称和描述符（descriptor）

3）方法的名称和描述符

Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载class文件的时候进行动态连接。也就是说，在class文件中不会保存各个方法和字段的最终内存布局信息，因此这些字段和方法符号引用不经过转换的话是无法被虚拟机使用的。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析并翻译到具体的内存地址之中。

常量池中的每一项常量都是一个表，共有11中结构不同的表结构数据，这11种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag, 取值1到12，缺少2），代表当前这个常量属于哪种常量类型。

这里对CONSTANT_Utf8_info型常量介绍一下，class文件中方法、字段等都需要用这个来描述名称，所以它的最大长度也就是Java中方法和字段名的最大长度。而这里的最大长度就是length的最大值，即u2类型能表达的最大值65535.

### 6.3.3 访问标志

在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或接口层次的访问信息，包括：这个class是类还是接口，是否定义为public类型，是否定义为abstract类型等等。

access_flags中一共有32个标志位可以使用，当前只定义了其中的8个，没有使用到的标志位要求一律为0。

举例，TestClass类被public修饰但没有声明final或abstract，并且它使用了JDK1.2之后的编译器进行编译，因此它的ACC_PUBLIC, ACC_SUPER标志应当为真，而其他标志为假。因此它的access_flags的值应为0x0001|0x0020=0x0021。

### 6.3.4 类索引、父类索引与接口索引集合

类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，class文件中由这三项数据来确定这个类的继承关系。

除了Object类，所有类的父类索引都不为0.

三类索引（集合）都按顺序排在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。

紧接着父类索引的，是接口索引计数器。如果该值为0，则后面接口的索引表不再占用任何字节，否则接口就按序排列。

从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0。

### 6.3.5 字段表集合

filed_info用于描述接口或类中声明的变量。字段filed包括了类级变量或实例级变量，但不包括在方法内部声明的变量。

在Java中描述一个字段可以包含什么信息？有：字段的作用域（public等）、类级还是实例级（static）、可变性（final）、并发可见性（volatile）、可否序列化（transient）、字段数据类型（基本类型、对象、数组）、字段名称。

字段修饰符放在access_flags中：

跟随者access_flags标志的是两项索引值：name_index和descriptor_index，它们都是对常量池的引用，分别代表着字段的简单名称及字段和方法的描述符。

简单名称就是指没有类型和参数修饰的方法或字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc"和”m"。

描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值。

如下的class文件字节流中，字段表集合从地址0x000000F8开始，第一个u2类型的数据为容量计数器fields_count，其值为0x0001，说明这个类只有一个字段表数据。

接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private。name_index的值为0x0005, 是一个CONSTANT_Utf8_info类型的字符串，其值为"m"。descriptor_index的值为0x0006，指向常量池的字符串“I”。

据此，可以推断出原代码定义的字段“private int m;"。

### 6.3.6 方法表集合

方法表的构成与字段表一样。

方法表的访问标志：

方法里的Java代码，经过编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“code”的属性里面。

下图中，方法表结合的入口地址为0x00000101。查看各个标志，可以对应到方法的代码。

在Java语言中，重载（overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名，就是一个方法中各个参数在常量池中的字段符号引用的集合。

### 6.3.7 属性表集合

在class文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

属性表集合对于顺序、长度、内容没有严格要求，只要不重名那任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。

对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则完全自定义的，只需要说明属性值所占用的位数长度即可。一个符合规则的属性表应该满足表6-14中所定义的结构。

1、Code属性

java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在code属性内。code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或抽象类中的方法就不存在code属性，如果方法表有则结构如下：

max_stack代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Frame）中的操作栈深度。

max_locals代表了局部变量表所需的存储空间。max_locals的单位是slot, 这是虚拟机为局部变量分配内存所使用的最小单位。对于byte, char, float, int, short, boolean, reference 和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个slot，而double和long这两种64位的数据类型则需要2个slot来存放。

方法参数、显式异常处理器的参数、方法体中定义的局部变量都需要使用局部变量表来存放。另外，max_locals的值并不是简单的局部变量所占slot之和，原因是slot可以被重用。当代码执行超出一个局部变量的作用域时，这个局部变量的slot就可以被其他局部变量所使用，编译器会根据变量的作用域来分类slot并分配给各个变量使用，然后计算出max_locals的大小。

code_length和code用来存储Java源程序编译后生成的字节码指令。Code属性是最重要的一个属性，如果把Java程序的信息分为代码和元数据，那么code属性用于描述代码，所有其他数据项目就都用于描述元数据。

根据以下的内容查字节码指令集，翻译“2A B7 00 0A B1”：

1）读入2A，查得aload_0, 这个指令的含义是将第0个slot中为reference类型的本地变量推送至栈顶

2）读入B7，查表得invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接受者

3）读入00 0A，这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造器“<init>”方法的符号引用

4）读入B1，查得return，含义是返回此方法，并且返回值为void

异常表的格式如下，它包含四个字段，含义是：如果在start_pc到end_pc行之间出现了类型为catch_type或其子类的异常，则转到第handler_pc行继续处理。当catch_type的值为0时，代表任何的异常情况都需要转向到handler_pc处进行处理。

2、Exceptions属性

这是与code属性平级的一项属性，作用是列举出方法中可能抛出的受检异常（checked Exceptions）。其中，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受检异常的类型。

3、LineNumberTable属性

用于描述Java源码行号与字节码行号之间的对应关系，用于定位异常所在行。非必需。

4、LocalVariableTable属性

用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。非必需。

如果取消，引用方法时不会生成具体的参数名称，IDE会使用arg0等占位符来代替原有的参数名。

5、SourceFile属性

用于记录生成这个class文件的源码文件名称。非必需。

6、ConstantValue属性

作用是通知虚拟机自动为静态变量赋值。

7、InnerClasses属性

用于记录内部类与宿主类之间的关联。

8、Deprecated及Synthetic属性

Deprecated属性用于表示某个类、字段或方法，已经被程序作者定位不再推荐使用，它可以通过在代码中使用@deprecated注释进行设置。

Synthetic属性代表此字段或方法并不是由Java源码直接产生的，而是由编译器自行添加的。

