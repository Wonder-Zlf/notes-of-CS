http请求详细
hyperText transfer protocol, HTTP, 超文本传输协议

基础概念
请求和响应报文
客户端发送一个请求报文给服务端，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。
请求报文结构：
GET http://www.example.com/ HTTP/1.1
/** 实际打开网页也可能是下面这样
:authority: github.com
:method: GET
:path: /CyC2018/CS-Notes/blob/master/notes/HTTP.md
:scheme: https
*/

// 摘取github的请求体示例
accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
accept-encoding: gzip, deflate, br
accept-language: zh-CN,zh;q=0.9
cache-control: max-age=0
cookie: xxx
if-none-match: W/"c419a8cb50f755e429a32a679b577769"
referer: https://github.com/CyC2018/CS-Notes
sec-ch-ua: "Google Chrome";v="87", " Not;A Brand";v="99", "Chromium";v="87"
sec-ch-ua-mobile: ?0
sec-fetch-dest: document
sec-fetch-mode: navigate
sec-fetch-site: same-origin
sec-fetch-user: ?1
upgrade-insecure-requests: 1
user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36

param1=1&param2=2


* 第一行是包含了请求方法、URL、协议版本
* 接下来多行都是请求首部header，每个首部都有一个首部名称，以及对应的值
* 一个空行用来分隔首部和内容主体body
* 最后是请求的内容主体



响应报文结构：
HTTP/1.1 200 OK
/** 实际打开网页也可能是下面这样
Request URL: https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md
Request Method: GET
Status Code: 200 
Remote Address: 20.205.243.166:443
Referrer Policy: no-referrer-when-downgrade
*/

// 摘取github的请求体示例
cache-control: max-age=0, private, must-revalidate
content-encoding: gzip
content-security-policy: xxx
content-type: text/html; charset=utf-8
date: Sun, 14 Nov 2021 12:43:30 GMT
etag: W/"3d419cd99c0d53b9d4d3d5cccd34145e"
expect-ct: max-age=2592000, report-uri="https://api.github.com/_private/browser/errors"
permissions-policy: interest-cohort=()
referrer-policy: no-referrer-when-downgrade
server: GitHub.com
set-cookie: has_recent_activity=1; path=/; expires=Sun, 14 Nov 2021 13:43:29 GMT; secure; HttpOnly; SameSite=Lax
set-cookie: xxx
strict-transport-security: max-age=31536000; includeSubdomains; preload
vary: X-PJAX, X-PJAX-Container
vary: Accept-Encoding, Accept, X-Requested-With
x-content-type-options: nosniff
x-frame-options: deny
x-github-request-id: C51E:7F4A:61CBAA:7B9C83:6191045A
x-xss-protection: 0

<!DOCTYPE html>
<html lang="en" data-color-mode="auto" data-light-theme="light" data-dark-theme="dark">
<head>
    <title>Example Domain</title>
// 省略... 
</body>
</html>


* 第一行包含协议版本、状态码以及描述，最常见的是200 OK 表示请求成功了
* 接下来多行也是首部内容
* 一个空行分隔首部和内容主体
* 最后是响应的内容主体



http状态码
服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。
状态码	类别	含义
1XX	Informational（信息性状态码）	接收的请求正在处理
2XX	Success（成功状态码）	请求正常处理完毕
3XX	Redirection（重定向状态码）	需要进行附加操作以完成请求
4XX	Client Error（客户端错误状态码）	服务器无法处理请求
5XX	Server Error（服务器错误状态码）	服务器处理请求出错
1XX 信息
* 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。


2XX 成功
* 200 OK
* 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
* 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。


3XX 重定向
* 301 Moved Permanently ：永久性重定向
* 302 Found ：临时性重定向
* 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
* 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
* 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
* 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。


4XX 客户端错误
* 400 Bad Request ：请求报文中存在语法错误。
* 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
* 403 Forbidden ：请求被拒绝。
* 404 Not Found


5XX 服务器错误
* 500 Internal Server Error ：服务器正在执行请求时发生错误。
* 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



headers
自己定义首部字段：http请求公共的请求参数，包括协议参数和业务参数
有4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段

通用首部字段
首部字段名	说明
Cache-control	控制缓存的行为
connection	控制不再穿法给代理的首部字段、管理持久连接
date	创建报文的日期时间
pragma	报文指令
trailer	报文末端的首部一览
transfer- encoding	指定报文主体的传输编码方式
upgrade	升级为其他协议
via	代理服务器的相关信息
warning	错误通知
请求首部字段
首部字段名	说明
accept	用户代理可处理的媒体类型
accept-charset	优先的字符集
accept-encoding	优先的内容编码
accept-language	优先的语言（自然语言）
authorization	web认证信息
expect	期待服务器的特定行为
from	用户的电子邮箱地址
host	请求资源所在服务器
if-match	比较实体标记（ETAG）
if-modified-since	比较资源的更新时间
if-none-match	比较实体标记（与if-match相反）
if-range	资源未更新时发送实体byte的范围请求
if-unmodified-since	比较资源的更新时间
max-forwards	最大传输逐条数
proxy-authorization	代理服务器要求客户端的认证信息
range	实体的字节范围请求
referer	对请求中URI的原始获取方
TE	传输编码的优先级
user-agent	http客户端程序的信息
响应首部字段
首部字段名	说明
accept- ranges	是否接受字节范围请求
age	推算资源创建经过时间
etag	资源的匹配信息
location	令客户端重定向至指定uri
Proxy-authenticate	代理服务器对客户端的认证信息
retry- after	对再次发起请求的时机要求
server	http服务器的安装信息
vary	代理服务器缓存的管理信息
www-authenticate	服务器对客户端的认证信息
实体首部字段
首部字段名	说明
allow	资源可支持的http方法
content- encoding	实体主体适用的编码方式
content- language	实体主体的自然语言
content- length	实体主体的大小
content- location	替代对应资源的URI
content- MD5	实体主体的报文摘要
content- Range	实体主体的位置范围
content- Type	实体主体的媒体类型
expires	实体主体过期的日期时间
last- modified	资源的最后修改日期时间
具体应用

cookie
http协议是无状态的，这主要是为了简化设计，使得能够处理大量并发事务。为了能够让一个站点识别用户，Http/1.1引入了cookie的设计。

用途
* 会话状态管理（商城、游戏等）
* 个性化设置
* 浏览器行为跟踪



技术
* http响应报文中的一个cookie首部行
* http请求报文中的一个cookie首部行
* 用户端系统中保留有一个cookie文件，由用户的浏览器进行管理
* 位于web站点的一个后端数据库



过程
服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]


客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry



session
对于大部分的客户端，session存储在cookie，session是一种基于cookie的用户状态管理方案。如果浏览器禁用cookie，则需要将session ID作为URL的参数传递。
对于服务端而言，session可以存储在服务器上的文件、数据库或者内存中，也可以将session存储在redis这种内存型数据库中，效率会更高。

使用过程
* 用户进行登录时，用户提交包含用户名和密码的表单，放入http请求报文中
* 服务器验证该用户名和密码，如果正确则把用户信息存储到redis中，它在redis中的key称为session ID
* 服务器返回的响应报文的set- cookie首部字段包含了这个session ID，客户端收到响应报文之后将该cookie值存入浏览器中
* 客户端之后对同一个服务器进行请求时会包含该cookie值，服务器收到之后提取出session ID，从redis中取出用户信息，继续之前的业务操作



cookie与session选择
* cookie只能存储ascii码字符串，而session则可以存储任何类型的数据，因此在考虑数据复杂性时首选session
* cookie存储在浏览器中，容易被恶意查看；如果非要将一些隐私数据存在cookie中，可以将cookie值进行加密，然后在服务器进行解密
* 对于大型网站，如果用户所有信息都存储session，开销过大所以并不建议



缓存

web缓存
web缓存服务器，是能够代表初始web服务器来满足http请求的网络实体。web缓存器又自己的存储空间，并在存储空间中保存最近请求过的对象的副本。
举例来说，假设浏览器请求www.someschool.edu/campus.gif，将会发生如下情况：
* 浏览器建立一个到web浏览器的TCP连接，并向web缓存器中的对象发送一个http请求。
* web缓存器进行检查，看看本地是否存储了该对象副本。如果有，web缓存器就向客户浏览器用http响应报文返回该对象。
* 如果web缓存器中没有该对象，它就打开一个与该对象的初始服务器的TCP连接。web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的http请求。在收到该请求后，初始服务器向该web缓存器发送具有该对象的http响应。
* 当web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用http响应报文发送该副本。



缓存优点
* 缓解初始服务器压力，通常将访问量更大的静态资源请求转移到缓存中处理
* 降低客户端获取资源的延迟，缓存服务器通常使用内存存储资源，读取速度更快；同时缓存服务器在地里位置上可以离客户端更近，甚至存储在浏览器中



实现方法
* 让代理服务器进行缓存
* 让客户端浏览器进行缓存



cache- control
http/1.1通过cache- control首部字段控制缓存
* 禁止进行缓存
    * 字段值时no-store则规定不能对请求或响应的任何一部分进行缓存  
* 强制确认缓存
    * no-cache则规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应  
* 私有缓存和公共缓存
    * private则规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中
    * public则规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中  
* 缓存过期机制
    * Max- age出现在请求报文中，并向缓存资源的换粗时间小于该指令指定的时间，那么就能接受该缓存
    * Max- age出现在响应报文中，表示缓存资源在缓存服务器中保存的时间
    * expires首部字段也可以告知缓存服务器该资源什么时候会过期
    * 在http/1.1中，会优先处理Max-age指令
    * 在http/1.0中，Max-age指令会被忽略掉  



缓存验证
需要先了解ETag首部字段的含义，它是资源的唯一标识。URL不能唯一表示资源，例如http://google.com/有中文和英文两个资源，只有ETag才能对这两个资源进行唯一标识。
ETag: "82e22293907ce725faf67773957acd12"


可以将缓存资源的ETag值放入if-none-match首部，服务器收到该请求后，判断缓存资源的ETag值和资源最新的ETag值是否一致，如果一致则表示缓存资源有效，返回304 Not Modified。
If-None-Match: "82e22293907ce725faf67773957acd12"


Last- Modified首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为ETag的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上if- Modified- Since来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的304 Not Modified响应报文。
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT




HTTPS
http有以下安全性问题：
* 使用明文进行通信，内容可能会被窃听；
* 不验证通信方的身份，通信方的身份可能遭遇伪装；
* 无法证明报文的完整性，报文有可能遭遇篡改



https并不是新的协议，而是让http和ssl（secure sockets layer）通信，再由ssl和tcp通信，也就是说https使用了隧道进行通信。
通过使用ssl，https具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。
￼


加密
1. 对称密钥加密


对称密钥加密（symmetric-key encryption），加密和解密使用同一密钥。
* 优点：运算速度快
* 缺点：无法安全地将密钥传输给通信方


￼

2. 非对称密钥加密


非对称密钥加密，又称公开密钥加密（public-key encryption），加密和解密使用不同的密钥。
公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。
* 优点：可以更安全地将公开密钥传输给通信发送方
* 缺点：运算速度慢


￼

3. https采用的加密方式


上面提到的对称密钥加密方式的传输效率更高，但是无法安全地将密钥secret key传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将secret key传输给通信方。https采用混合的加密机制，正是利用了上面的方案：
* 使用非对称密钥加密方式，传输对称密钥加密方式所需要的secret key，从而保证安全性
* 获取到secret key后，再使用对称密钥加密方式进行通信，从而保证效率


￼

认证
通过使用证书来对通信方进行认证。
数字证书认证机构（CA，certificate authority）是客户端与服务器双方都可信赖的第三方机构。
服务器的运营人员向CA提出公开密钥的申请，CA在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。
进行https通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。
￼

完整性保护
ssl提供报文摘要功能来进行完整性保护。
http也提供了MD5报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算MD5的值，通信接收方是无法意识到发生了篡改。
https的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

https的缺点
* 因为需要进行加密解密等过程，因此速度会更慢
* 需要支付证书授权的高额费用



GET和POST比较
作用
GET用于获取资源，而POST用于传输实体主体。

参数
GET和POST的请求都能使用额外的参数，但是GET的参数是以查询字符串出现在URL中，而POST的参数存储在实体主体中。不能因为POST参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具Fiddler查看。
因为URL只支持ASCII码，因此GET的参数中如果存在中文等字符就需要先进行编码。例如中文会转换%E4%B8%AD%E6%96%87，而空格会转换为%20。POST参数支持标准字符集。
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1


POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2



安全
安全的http方法不会改变服务器状态，也就说它只是可读的。
GET方法是安全的，而POST却不是，因为POST的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
安全的方法除了GET之外，还有HEAD、OPTIONS。
不安全的方法除了POST之外，还有PUT、DELETE。

幂等性
幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说，幂等方法不应该具有副作用（统计用途除外）。
所有的安全方法也都是幂等的。
在正确实现的条件下，GET，HEAD，PUT和DELETE等方法都是幂等的，而POST方法不是。
GET/pageX Http/1.1是幂等的，连续调用多次，客户端接收到的结果都是一样的：
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1


POST/add_row Http/1.1不是幂等的，如果调用多次，就会增加多行记录：
POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row


DELETE /idX/delete Http/1.1是幂等的，即时不同的请求接收到的状态码不一样：
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404



XMLHttpRequest
为了阐述POST和GET的另一个区别，需要先了解XMLHttpRequest：
XMLHttpRequest是一个API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL来获取数据的简单方式，并且不会使整个页面刷新。XMLHttpRequest在AJAX中被大量使用。


* 在使用XMLHttpRequest的POST方法时，浏览器会发送Header再发送Data。但并不是所有浏览器会这么做，例如火狐就不会。
* 而GET方法Header和Data会一起发送


