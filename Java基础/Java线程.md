# Java线程

## 1、启动线程用start还是run

thread.start()启动线程，启动后如果有资源直接运行。start后进入就绪状态，在JVM中进入队列排队等CPU资源。

thread.run()运行线程，当CPU分配资源后，线程从就绪状态进入运行状态。运行状态时，只能继续进入阻塞状态或者死亡状态。但是阻塞状态可以继续进入就绪状态。

阻塞状态：

1）等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。

2）同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。

3）其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

## 2、多线程有几种实现？并发和同步如何解决？

### 2.1 多线程的实现

Java提供的三种创建线程的方法：

1）通过继承thread类

2）通过实现runnable接口

3）通过callable和future创建线程

比较三种方式：

1）采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。

2）使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。

扩展：

1）线程池Executors实现多线程并发

2）spring这类中间件创建多线程

### 2.2 并发和同步

Java启动多线程实现并发，通过synchronized和volatile控制变量同步。

扩展的看，实现同步可以把数据库事务和乐观锁考虑进来。

参考：

https://blog.csdn.net/king_kgh/article/details/78213576

## 3、守护线程？用什么方法实现守护线程？

### 3.1 什么是

线程的生命周期是Java的main线程启动所有线程，所有线程执行完成后JVM进程关闭退出。

换言之，如果有一个线程没有结束，JVM不能退出。假设程序中存在定时器，那定时器默认无限循环不会手动去关闭，JVM还怎么退出？

使用守护线程标记定时器，JVM识别守护线程后会无视掉继续结束进程。

相应地，不可以给守护进程持有资源，否则JVM关闭会丢失数据甚至报错。

### 3.2 方法

public final void setDaemon(boolean on): 将该线程标记为守护线程或用户线程

参考：

https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074

## 4、如何停止一个线程？

1）Thread在执行完成run方法后就会自动结束

2）如果是无限循环的线程，可以设置exit条件

3）JVM结束进程会关闭守护进程（如果是）

4）Thread的stop等不安全方法关闭

## 5、举例说明一个线程不安全的例子？

两个线程访问同一个对象的同一个方法，修改同一个变量的值。

如果没有加synchronized, 两个线程会冲突操作，例如有一个线程的修改结果会被覆盖从而丢失。

## 6、解释synchronized关键字

用于控制所修饰的方法在同一时刻不能被重复访问，保证操作原子性和线程安全。

## 7、当一个线程进入一个对象的synchronized方法，其他线程是否能否进入此线程的其他方法？

一个对象的方法A加了synchronized，方法B也加了，方法C没加。

当A被一个线程访问了：方法B不能被访问进入，方法C可以被进入

原因是Java的对象锁只有一个，锁定的是对象级别，不能锁定两个方法，所以整个对象的synchronized方法都被锁了。

