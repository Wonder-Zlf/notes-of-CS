# 10.7 缓存搜索结果

## 题目描述

想象有个web服务器，实现简化版搜索引擎。这套系统有100台机器来响应搜索查询，可能会对另外的机器集群调用processSearch(string query)以得到真正的结果。响应查询请求的机器是随机挑选的，因此两个同样的请求不一定由同一台机器响应。方法processSearch的开销很大，请设计一种缓存机制，缓存最近记此查询的结果。当数据发生变化时，务必说明该如何更新缓存。



## 自己的方案

简单能设计出的：

1）首先用队列来实现先进先出，淘汰旧数据的条件就是时间戳；

2）使用散列可以提高查询速度，对于数量级较大的缓存系统，必须要使用散列或者其他查询树；

问题是怎么把散列和队列（链表）结合起来？更新散列表比较容易，但是大数量级的队列查找的开销巨大。



## 对面试官提问

问对了问题，就得到一半的答案。下面是作者给出的一些关键假设，也就是要和面试官确认的背景条件，不同的条件会要求完全不同的方案。

关键假设如下：

1）除了必要时往外调用processSearch，所有查询处理都在最初被调用的那台机器上完成。

2）我们假设缓存的搜索查询数量级庞大，达到几百万的规模。

3）机器之间的调用速度相对较快。

4）给定的查询结果是一个有序的网址列表，每个网址关联50个字符的标题和200个字符的摘要。

5）最常见的查询非常热门，以至于它们总是会存在缓存中。



## 作者的方案

### 系统需求

设计缓存机制时，显然我们需要支持两个主要功能：

1）给定某个键，快速有效的找出来；

2）旧的数据会过期，从而让它可被新的数据取代。

此外，当某次查询的结果改变时，我们还必须处理缓存的更新或清除。因为有些查询非常常见，有可能长驻在缓存中，不能等着该数据过期。



### 步骤1：设计单个系统的缓存

同样是基本构造法，先从单台机器开始设计，然后扩展得到更大系统。

最开始的问题，该创建什么样的数据结构？

使用链表（队列）可以轻易清除旧数据，只需将”新鲜“的数据移到链表前方。当链表超过一定大小时，我们可以删除链表末尾的元素。

散列表可以高效查找数据，但是通常无法轻易清除数据。



为了满足系统需求，作者将两种数据结构融合在一起。

首先创建一个链表，每次访问结点后，这个结点就会移至链表首部。这样一来，链表尾部总是包含最陈旧的信息。此外，还需要一个散列表，将查询映射为链表中相应的结点。这样不仅可以有效返回缓存的结果，还能将适当的结点移至链表首部，从而更新其”新鲜度“。



个人没有图解作者的数据结构设计，猜想应该是和堆类似的结构，被访问的结点会被上移到堆顶，最旧的数据都在叶子节点上。



伪代码：

```java
public class Cache {
    public static int MAX_SIZE = 10;
    public Node head, tail;
    public HashMap<String, Node> map;
    public int size = 0;
    
    public Cache() {
        map = new HashMap<String, Node>();
    }
    
    // 将结点移至链表前方
    public void moveToFront(Node node) {...}
    public void moveToFront(String query) {...}
    
    // 从链表中移除结点
    public void removeFromLinkedList(Node node) {...}
    
    // 从缓存中获取结点，并更新链表
    public String[] getResults(String query) {
        if (!map.containsKey(query)) return null;
        
        Node node = map.get(query);
        moveToFornt(node); // 更新新鲜度
        return node.results;
    }
    
    // 将结果插入链表，并散列
    public void insertResults(String query, String[] results) {
        if (map.containsKey(query)) { // 更新值
            Node node = map.get(query);
            node.results = results;
            moveToFront(node); // 更新新鲜度
            return;
        }
        
        Node node = new Node(query, results);
        moveToFront(node);
        map.put(query, node);
        
        if (size > MAX_SIZE) {
            map.remove(tail.query);
            removeFromLinkedList(tail);
        }
    }
}
```





### 步骤2：扩展到多台机器

现在我们设计好了单台机器的缓存，接下来要考虑如何扩展。

题目描述中，不能保证某个查询一定会发送给同一台机器。那么缓存跨机器共享到了什么程度呢？这既是一个和面试官讨论的问题，也是不同方案的主要区别。

下面给出几种方案，但并不是说任一是最优的。

选择1：每台机器都有各自的缓存

也就是说，如果“吃瓜”在短时间被发送给机器1两次，第二次会从缓存中返回。但是如果再接着“吃瓜”被发送到机器2，那么就会成为全新的查询在机器2上执行。

优点是相对快速，结构简单，机器间不互相调用。缺点是，会存储大量重复的查询在不同机器缓存上。



选择2：每台机器都有一个缓存的副本

另一个极端是，我们可以给每台机器一个缓存的完整副本。当新的条目添加至缓存时，它们会被发送给所有机器。包括连接和散列表在内的整个数据结构都会被复制。

这种设计意味着常见的查询几乎总是会在缓存里，因为所有机器的缓存都是相同的。但是，主要的缺点是更新缓存意味着要将数据发送到N台机器。此外，每个条目占用的空间是上一种做法的N倍，因此缓存所能存放的数据要少得多。



选择3：每台机器存储一部分缓存

将缓存分割，每台机器存放缓存的不同部分。然后，当机器i 需要查找某次查询的结果，它会算法哪一台机器持有这个值，接着请求这台机器在它的缓存里查询。

但是，机器i 怎么知道哪一台机器持有这部分散列表？

一种选择是根据算是hash(query)%N指定查询的结果。然后，机器i 只需利用这个算式即可得出存储结果的机器j。

因此，当新的查询进入机器i 时，这台机器会应用上面的算式从而调用机器j。随后，机器j 会从它的缓存中返回待查询的值，或者调用processSearch(query)得到结果。

**实质上这里解决的是，查询如何分配到不同的机器上呢？即使没有缓存也是负责处理这个请求的。**



### 步骤3：内容改变时更新结果

有些查询可能非常热门，会一直留在缓存中。当某些内容改变时，我们需要通过某种机制来定期或“按需”刷新缓存的结果。

要回答这个问题，我们需要考虑结果何时才会改变，同样也是要和面试官讨论。假设结果改变的主要时机如下：

1）网址对应的内容变了

2）为反映页面排名变化，搜索结果的排序也变了

3）特定查询出现了新页面

为了处理情况1和2，可以另外创建一个散列表，指示哪个缓存查询与特定网址关联。这些缓存可以完全独立于其他缓存进行处理，并放在不同的机器上。不过，这种解法可能需要大量的数据。

另外，如若数据不要求即时刷新，我们可以定期遍历每台机器上存储的缓存，将于更新过的网址相关联的结果清除掉。



情况3很难处理。我们可以通过解析新网址对应的内容并从缓存中清除这些单一词的查询，来更新单一词查询。不过，这仅能处理单一词的查询。

情况3有个不错的处理方式，就是实现缓存的“自动逾期”。也就是对每个缓存加上一个超时期限，之后自动过期清除。



### 步骤4：继续改进

再尝试做出一些优化。

其中一个是更好地支持有些查询非常热门的情况。例如，假设所有查询中，有1%都含有某个字符串。那么，机器i 不必每次都将这个搜索请求转给机器j，应该只向j 转发一次，然后机器i 就可以直接将结果存储在自己的缓存中。

另一个优化是针对“自动过期”机制的。按照前面的描述，这个机制会在X分钟后清除任意数据。然后，相比其他数据，我们希望某些数据（如新闻）的更新更频繁，可以根据主题或网址实现不同的自动逾期机制。对于后一种情况，根据页面以往的更新频度，每个网址会设置不同的超时值。该搜索查询的超时值是每个网址超时值的最小值。

