# cc189经典题 找出数字x的秩

## 题目描述

假设你正在读取一串整数。每隔一段时间，你要找出数字x的秩（小于或等于x的数目）。请实现数据结构和算法支持这些操作。也就是说，实现track(int x)方法，每读入一个数字都会调用这个方法；以及getRankOfNumber(int x)方法，返回值为小于或等于x的元素个数，不包括本身。

## 不写具体代码，仅讨论下解决思路

对于无序的存储结构，查找秩的代价会随着数量级的增长而越来越大。所以我们必定要设计一个有序的存储结构，才能保证在有效时间内返回查找结果getRankOfNumber()。

相对简单的方式，是用数组存放所有排序好的元素。这样可以实现查找有序，主要是二分查找后返回索引。但是插入元素会非常低效，因为总是要复制粘贴一部分数据。

很创意的思路是使用二叉查找树而非数组。插入的代价是O(logn)，其中n为树的大小。getRankOfNumber()使用中序遍历，并在访问结点时计数。为了提高性能，还可以为每个结点增加一个计数域，专门统计左子树的结点数量。

在查找期间，只要向左移动，计数器变量就不会变。为什么呢？因为右边元素虽然被跳过，但他们都比x大。而向右移动，跳过的左边元素都比x小，都是要被统计的。

下图的例子，我们要查找24。

首先与根结点20比较，发现24在右子树，计数+4，+1。

然后与25比较，跳过25。与23比较，判断24在右边，计数+1。

最后查找到24，返回当前计数值为6。
