# 摊还分析

摊还分析，即我们求数据机构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。不同于平均情况分析，它不涉及概率，它可以保证最坏情况下每个操作的平均性能。

本章前三节介绍了摊还分析中最常用的三种技术。

聚合分析（aggregate analysis）用来确定一个n个操作的序列的总代价的上界T(n)，因而每个操作的平均代价为T(n)/n。

核算法（accounting method）将序列中某些较早的操作的“余额”作为“预付信用”存储起来，与数据结构中的特定对象相关联。在操作序列中随后的部分，存储的信用即可用来为那些缴费少于实际代价的操作支付差额。

势能法（potential method）将信用作为数据结构的“势能”存储起来，与核算法不同，它将势能作为一个整体存储，而不是将信用与数据结构中单个对象关联分开存储。

## 1、聚合分析

### 栈操作

对一个栈进行基本的push、pop操作，时间都是O(1)。现在我们增加一个新的栈操作MULTIPOP，它删除栈顶的k个对象。

我们来分析一个由n个PUSH、POP和MULTIPOP组成的操作序列在一个空栈上的执行情况。MULTIPOP操作最坏情况代价为O(n)，因为栈的大小最大为n。因此，这个序列最坏代价为O(n^2)。

但是使用聚合分析，我们考虑整个序列的n个操作，可以得到更好的上界。对于一个非空的栈，可以执行的POP操作的次数（包括了MULTIPOP中调用POP次数）最多和PUSH操作的次数相当，即最多n次。因此，对任意的n值，任意一个由n个PUSH、POP、MULTIPOP组成的操作序列，最多花费O(n)时间。一个操作的平均时间为O(n)/n=O(1)，因此这个序列的栈操作的摊还代价都是O(1)。

### 二进制计数器递增

![1640508004747](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1640508004747.png)


对上图算法运行时间粗略分析会得到每个操作O(k)的时间复杂度，但这是一个正确却不精确的界值。

实际上，n次调用INCREMENT时A[0]翻转了n次，而A[1]则是n/2，A[i]则是n/(2^i)。翻转总数为

![1640507995534](C:\Users\wonde\AppData\Roaming\Typora\typora-user-images\1640507995534.png)

因此，每个操作的摊还代价为O(n)/n=O(1)。



## 2、核算法

用核算法进行摊还分析时，我们对不同操作赋予不同费用，赋予某些操作的费用可能多于或少于其实际代价。我们将赋予一个操作的费用称为它的摊还代价。当一个操作的摊还代价超出其实际代价时，我们将差额存入数据结构的特定对象，存入的差额称为“信用”。

对于后续操作中摊还代价小于实际代价的情况，信用可以用来支付差额。

因此，我们可以将一个操作的摊还代价分解为其实际代价和信用。不同操作可能有不同的摊还代价。

如果用ci表示第i个操作的真实代价，用c'i表示其摊还代价，则对任意n个操作的序列，要求sum(c'i)>=sum(ci)。数据结构中存储的信用恰好等于总摊还代价与总实际代价的差值，即sum(c'i)-sum(ci)。

并且，信用必须一直为非负值。如果出现非负值，那当时集合的总摊还代价就不再是总实际代价的上界。

### 栈操作

为了说明摊还分析的核算法，继续用栈的例子。

栈操作的实际代价和赋予摊还代价如下：

----------------------------------------------------------------

操作	实际代价	摊还代价
PUSH	1	2
POP	1	0
MULTIPOP	min(k,s)	0

----------------------------------------

我们对PUSH操作赋予了2的摊还代价，则每个PUSH操作存入了1的“信用”。由于每个POP或MULTIPOP的子操作，均对应一个PUSH。所以POP操作消耗虽然摊还代价为0，可是实际代价可以消耗之前PUSH的1的信用。

总的摊还代价，对于任意n个操作的序列，都是总实际代价的上界。由于总摊还代价为O(n)，总实际代价也是。

### 二进制计数器递增

作为核算法的另一个例子，我们分析在一个从0开始的二进制计数器上执行INCREMENT操作。对一个置位操作，我们设其瘫痪代价为2，这样每次0置1时就消耗1并存入1的信用。等到从1复位0时，消耗掉之前存入的1的信用。

这里，任何时刻信用值都是非负的。对于n个操作，总摊还代价为O(n)，为总实际代价的上界。

## 3、势能法

势能是数据结构中信用的加总，将其释放即可用来支付未来操作的代价。我们将势能与整个数据结构而不是特定对象关联。

我们对一个初始数据结构D0执行n个操作。对每个i=1,2...n，令ci为第i个操作的实际代价，令Di为在数据结构Di-1上执行第i个操作得到的结果数据结构。势函数T将每个数据结构Di映射到一个实数T(Di)，此值即为关联到数据结构Di的势。

第i个操作的摊还代价c'i用势函数T定义为：c'i=ci+T(Di)-T(Di-1)。

因此，每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。

栈操作、二进制计数器递增的推导见原书。

